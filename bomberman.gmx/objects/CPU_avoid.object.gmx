<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>walkDownSpr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>CPU_init</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//best = [xgoal, ygoal, bestvalue(0-2), direction, bestvaluebackup(0,3), backupx, backupy]
best[0] = x; 
best[1] = y;
best[2] = 0;
best[3] = noone; 
best[4] = 0;
best[5] = x;
best[6] = y;
mp_grid_add_instances(grid2, flame, false);
//mp_grid_add_instances(grid, cursePowerUp, false);



//check up
if(mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 - 1) == 0 &amp;&amp; best[2] &lt; 2)
{
    best[0] = x;
    best[1] = y-32;
    best[2] = 1;
    best[3] = 90;
    if(mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 - 1) == 0)
    {
        best[2] = 2;
    }
    //CHECK FURTHER IF NOT IN CLEAR//
    if(mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 - 2) == 0 &amp;&amp; best[2] &lt; 2)
    {
        if(mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 - 2) == 0)
        {
            best[4] = 3;
            best[5] = x;
            best[6] = y-32;
        }
        else
        {
            if( (mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 - 3) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 - 3) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 +1  , (y-16)/32 - 2) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 + 1, (y-16)/32 - 2) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 -1, (y-16)/32 - 2) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 - 1, (y-16)/32 - 2) == 0))
            {
                show_debug_message("TESTup");
                best[4] = 3;
                best[5] = x;
                best[6] = y-32;
            }
        }
    }
    //*/END EXTENDED CHECK
}
//check down
if(mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 + 1) == 0 &amp;&amp; best[2] &lt; 2)
{
    best[0] = x;
    best[1] = y+32;
    best[2] = 1;
    best[3] = 270;
    if(mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 + 1) == 0)
    {
        best[2] = 2;
    }
        //CHECK FURTHER IF NOT IN CLEAR//
    if(mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 + 2) == 0 &amp;&amp; best[2] &lt; 2)
    {
        if(mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 + 2) == 0)
        {
            best[4] = 3;
            best[5] = x;
            best[6] = y+32;
        }
        else
        {
            if( (mp_grid_get_cell(grid2, (x-16)/32 , (y-16)/32 + 3) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 , (y-16)/32 + 3) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 +1  , (y-16)/32 + 2) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 + 1, (y-16)/32 + 2) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 -1, (y-16)/32 + 2) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 - 1, (y-16)/32 + 2) == 0))
            {
                show_debug_message("TESTDown");
                best[4] = 3;
                best[5] = x;
                best[6] = y+32;
            }
        }
    }
    //*/END EXTENDED CHECK
}
//check right
if(mp_grid_get_cell(grid, (x-16)/32 + 1 , (y-16)/32) == 0 &amp;&amp; best[2] &lt; 2)
{
    //game_restart();
    best[0] = x+32;
    best[1] = y;
    best[2] = 1;
    best[3] = 0;
    if(mp_grid_get_cell(grid2, (x-16)/32 + 1, (y-16)/32) == 0)
    {
        best[2] = 2;
    }
        //CHECK FURTHER IF NOT IN CLEAR//
    if(mp_grid_get_cell(grid, (x-16)/32 + 2, (y-16)/32) == 0 &amp;&amp; best[2] &lt; 2)
    {
        if(mp_grid_get_cell(grid2, (x-16)/32 + 2, (y-16)/32) == 0)
        {
            best[4] = 3;
            best[5] = x + 32;
            best[6] = y;
        }
        else
        {
            if( (mp_grid_get_cell(grid2, (x-16)/32 + 3, (y-16)/32) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 + 3, (y-16)/32) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 + 2, (y-16)/32 - 1) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 + 2, (y-16)/32 - 1) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 + 2, (y-16)/32 + 1) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 + 2, (y-16)/32 + 1) == 0))
            {
                show_debug_message("TESTRight");
                best[4] = 3;
                best[5] = x + 32;
                best[6] = y;
            }
        }
    }
    //*/END EXTENDED CHECK
}
if(mp_grid_get_cell(grid, (x-16)/32 - 1 , (y-16)/32) == 0 &amp;&amp; best[2] &lt; 2)
{
    //game_restart();
    best[0] = x - 32;
    best[1] = y;
    best[2] = 1;
    best[3] = 180;
    if(mp_grid_get_cell(grid2, (x-16)/32 - 1, (y-16)/32) == 0)
    {
        best[2] = 2;
    }
        //CHECK FURTHER IF NOT IN CLEAR//
    if(mp_grid_get_cell(grid, (x-16)/32 - 1, (y-16)/32) == 0 &amp;&amp; best[2] &lt; 2)
    {
        if(mp_grid_get_cell(grid2, (x-16)/32 - 1, (y-16)/32) == 0)
        {
            best[4] = 3;
            best[5] = x - 32;
            best[6] = y;
        }
        else
        {
            if( (mp_grid_get_cell(grid2, (x-16)/32 - 3, (y-16)/32 - 0) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 - 3, (y-16)/32 - 0) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 - 2, (y-16)/32 + 1) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 - 2, (y-16)/32 + 1) == 0) ||
                (mp_grid_get_cell(grid2, (x-16)/32 - 2, (y-16)/32 - 1) == 0 &amp;&amp; mp_grid_get_cell(grid, (x-16)/32 - 2, (y-16)/32 - 1) == 0))
            {
                show_debug_message("TESTleft");
                best[4] = 3;
                best[5] = x - 32;
                best[6] = y;
            }
        }
    }
    //*/END EXTENDED CHECK
}
if(best[2] == 1 &amp;&amp; best[4] == 3)
{
    best[0] = best[5];
    best[1] = best[6];
    bets[2] = 2;
    if(best[0] != x)
    {
        if((best[0] - x)/abs(best[0] - x) == -1)
        {
            best[3] = 180;
        }
        else if((best[0] - x)/abs(best[0] - x) == 1)
        {
            best[3] = 0;
        }
    }
    else if(best[1] != y)
    {
        if((best[1] - y)/abs(best[1] - y) == -1)
        {
            best[3] = 90;
        }
        else if((best[1] - y)/abs(best[1] - y) == 1)
        {
            best[3] = 270;
        }
    }
}

if(best[2] == 0)
{
    instance_change(CPU_init, true);
}



if(best[3] == 0)
{
    sprite_index = walkRightSpr;
}
else if(best[3] == 90)
{
    sprite_index = walkUpSpr;
}
else if(best[3] == 180)
{
    sprite_index = walkLeftSpr;
}
else if(best[3] == 270)
{
    sprite_index = walkDownSpr;
}

alarm[0] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    dir = best[3];
    instance_change(CPU_init, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    ///simplified AI
    depth = -y;
    if(best[3] == 0)
    {
        sprite_index = walkRightSpr;
    }
    else if(best[3] == 90)
    {
        sprite_index = walkUpSpr;
    }
    else if(best[3] == 180)
    {
        sprite_index = walkLeftSpr;
    }
    else if(best[3] == 270)
    {
        sprite_index = walkDownSpr;
    }
    
    image_speed = 0.18;
    move_contact_solid(best[3],move_speed);
   if  (x == best[0] &amp;&amp; y == best[1])
    {
        
        //image_speed = 0;
        //image_index = 1;
        dir = best[3];
        instance_change(CPU_init, true);
    }
   
    depth = -y;
    //image_blend = c_black;
 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,48</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
